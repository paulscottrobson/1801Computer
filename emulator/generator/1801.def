// *************************************************************************************************
// *************************************************************************************************
//
//									1801 CPU Generation Specification
//
// *************************************************************************************************
// *************************************************************************************************
//
//		* 		is substituted for (opcode - (base & 0xF8))
//		
//		R0-RF			16 bit registes
//		D,T 			8 bit registers
//		X,P 			4 bit registers
//		DF,IE 			1 bit registers
//		R[P]			16 pointers to R0-RF for indirect access.
//
//		READ/WRITE		Access memory using MB and MA
//		INPUT/OUTPUT 	Macros accessing I/O ports.
//
// *************************************************************************************************
//										Control Macros
// *************************************************************************************************

:#define RESET()		P = 0;R0 = 0;IE = 1
:#define INTERRUPT()	if (IE) { T = (X << 4)|P;X = 2;P = 1;IE = 0; }

:#define FETCH() 		MA = (*RP[P])++;READ()

// *************************************************************************************************
//									  Register operations
// *************************************************************************************************

10-1F	"INC R*"		R*++
20-2F	"DEC R*"		R*--

80-8F 	"GLO R*"		D = R* & 0xFF
90-9F	"GHI R*"		D = (R* >> 8) & 0xFF
A0-AF	"PLO R*"		R* = (R* & 0xFF00) | D
B0-BF 	"PHI R*"		R* = (R* & 0x00FF) | (D << 8)

// *************************************************************************************************
//										Memory Reference
// *************************************************************************************************

40-4F	"LDA R*"		MA = R*;READ();D = MB;R*++
50-5F 	"STR R*"		MA = R*;MB = D;WRITE()

:#define READMX()		MA = *RP[X];READ()
:#define ADD(a,b,c)		tmp16 = (a)+(b)+(c);D = (tmp16 & 0xFF);DF = (tmp16 >> 8) & 1

// *************************************************************************************************
//									ALU Operations (Indexed)
// *************************************************************************************************

F0 		"LDX"			READMX();D = MB
F1 		"OR"			READMX();D = D | MB
F2 		"AND"			READMX();D = D & MB
F3 		"XOR"			READMX();D = D ^ MB

F4 		"ADD"			READMX();ADD(D,MB,0)
F5 		"SD"			READMX();ADD(D^0xFF,MB,1)
F6 		"SHR"			DF = D & 1;D = (D >> 1) & 0x7F
F7 		"SM"			READMX();ADD(D,MB^0xFF,1)

// *************************************************************************************************
//									ALU Operations (Immediate)
// *************************************************************************************************

F8 		"LDI #"			FETCH();D = MB
F9 		"ORI #"			FETCH();D = D | MB
FA 		"ANI #"			FETCH();D = D & MB
FB 		"XRI #"			FETCH();D = D ^ MB

FC 		"ADI #"			FETCH();ADD(D,MB,0)
FD 		"SDI #"			FETCH();ADD(D^0xFF,MB,1)
FF 		"SMI #"			FETCH();ADD(D,MB^0xFF,1)

// *************************************************************************************************
//										Branch instructions
// *************************************************************************************************

:#define BRANCH()		*RP[P] = (*RP[P] & 0xFF00) | MB

30 		"BR #"			FETCH();BRANCH()
32 		"BZ #"			FETCH();if (D == 0) BRANCH()
33 		"BDF #"			FETCH();if (DF != 0) BRANCH()
34 		"B1 #"			FETCH();if (EFLAG(1) != 0) BRANCH()
35 		"B2 #"			FETCH();if (EFLAG(2) != 0) BRANCH()
36 		"B3 #"			FETCH();if (EFLAG(3) != 0) BRANCH()
37 		"B4 #"			FETCH();if (EFLAG(4) != 0) BRANCH()

38 		"SKP"			FETCH();
3A 		"BNZ #"			FETCH();if (D != 0) BRANCH()
3B 		"BNF #"			FETCH();if (DF == 0) BRANCH()
3C 		"BN1 #"			FETCH();if (EFLAG(1) == 0) BRANCH()
3D 		"BN2 #"			FETCH();if (EFLAG(2) == 0) BRANCH()
3E 		"BN3 #"			FETCH();if (EFLAG(3) == 0) BRANCH()
3F 		"BN4 #"			FETCH();if (EFLAG(4) == 0) BRANCH()

// *************************************************************************************************
//											Control
// *************************************************************************************************

00 		"IDL"			(*RP[P])--

D0-DF 	"SEP R*"		P = 0x*
E0-EF 	"SEX R*"		X = 0x*

:#define INTRET(s) 		READMX();X = (MB >> 4) & 0xF;P = (MB & 0x0F);(*RP[X])++;IE = (s)

70		"RET"			INTRET(1)
71		"DIS"			INTRET(0)

78 		"SAV"			MA = *RP[X];MB = T;WRITE()

// *************************************************************************************************
//									Input/Output Byte Transfer
// *************************************************************************************************

61-67 	"OUT *"			READMX();OUTPUT(*,MB);(*RP[X])++
69-6F 	"INP *"			MB = *RP[X];MA = INPUT(*);WRITE()
